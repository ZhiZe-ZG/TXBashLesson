# 0X05 文件操作

上一节介绍了路径相关的知识.这一节就来介绍基本的文件操作.这些文件或目录操作都是GNU Coreutils提供的.

## ls

使用ls命令可以查看当前路径下的文件.

ls有一些可以配置的选项,例如:

```shell
ls -l
```

表示ls命令除了显示文件名,还要显示文件的修改时间,权限等详细命令.

默认ls命令不会显示文件名以句点'.'开头的文件.使用

```shell
ls -a
```

表示显示所有文件,包括以句点开头的文件.

对于Coreutils提供的命令(或者应该说绝大多数Linux系统上的命令),他们的这种单字母的用于配置命令的参数可以复合使用(只用写一个连词符作为开头).例如:

```shell
ls -al
```

表示显示所有文件的详细信息.

## ls指定显示路径

ls后加路径作为参数,就会显示指定路径下的文件.例如:

```shell
ls /bin
```

当配置参数和路径同时使用时,应该把配置参数放在前边.例如:

```shell
ls -al /bin
```

## ls显示颜色

ls命令可以通过颜色来区分不同类型的文件.有的发行版上默认打开了彩色显示的功能.如果你的ls显示出来的是黑白的文件名,可以使用以下命令来显示彩色版:

```shell
ls --color=auto
```

在这种模式下,不同类型的文件会显示为不同的颜色.如果你不喜欢默认的配色方案.可以自己定义ls命令的配色方案.具体方法见Coreutils手册或者这个网站:

<http://www.bigsoft.co.uk/blog/index.php/2008/04/11/configuring-ls_colors>

下边这个网站可以自动生成控制ls配色方案的字符串:

<https://geoff.greer.fm/lscolors/>

除了ls,Coreutils中还有一些和显示指定路径下文件相关的命令,如dir,vdir,dircolors.

## touch

创建文件的方式非常多,基本上能编辑文件的软件都能创建文件.比如用vim,emacs等都能创建文本文件.

使用命令touch时,如果参数是一个不存在的文件名,则会创建一个同名的空文件.

如果参数是一个已经存在的文件.则会刷新文件的最后修改时间为使用touch命令的时间(除此之外不会给文件带来任何修改).

## 创建目录

使用命令mkdir创建一个空目录.目录名为mkdir命令的参数.

注意,无论是touch创建空文件还是mkdir创建空目录.如果直接给一个名称,就会在当前路径下创建.如果参数是一个路径,则会在指定路径下创建.

例如:

```shell
mkdir /usr/MyTest
```

表示在'/usr'下创建一个叫'MyTest'的空目录.

其他命令中涉及文件名的地方也大都像这样可以换成路径.以后不会再赘述这一点.

## 一切皆文件

类Unix系统(包括Linux)的设计哲学是一切都是文件.虽然实际实现的时候打了一点折扣,但是说目录是特殊一点的文件这是没有错的.接下来要介绍的复制移动删除等命令适用于普通文件也适用于目录.如果要查看一个文件的类型,使用file命令.例如:

```shell
file /bin
file /bin/bash
```

## 复制

```shell
cp ~/test ~/test2
```

cp命令第一个参数是被复制的文件,第二个参数是要复制到的路径,和复件的名称.如果第二个参数路径只是一个路径,没有包含最后的文件名.就会沿用原文件的文件名.如果要执行复制的时候,发现复件的名字会和已经存在的文件冲突,则复制操作不会被执行.

如果被复制的对象是一个目录.则需要在cp之后加参数'-r'表示递归复制(遇到目录就复制其所有内容).例如:

```shell
cp -r ~/test ~/test2
```

在复制目录的时候特别注意,如果目标路径(test2)是一个已经存在的目录,则会把原文件复制到这个路径之下.如果目标路径最终指向一个不存在的文件,则会把cp复制并重命名.例如这个命令中如果test2已经存在,而且是一个目录则会把test复制到test2下.如果test2不存在,则会把cp复制并重命名为test2.

## 移动

```shell
mv ~/test ~/hello/test
```

移动命令mv类似于复制命令.不同之处在于复制之后原文件仍然存在.但是移动之后原文件就不存在了.这条命令表示把test移动到hello目录下.这条命令其实可以进一步简写为:

```shell
mv test hello
```

利用移动命令的特性,可以完成文件重命名的操作.

```shell
mv test test2
```

这条命令表示把当前路径下的test重命名为test2.当然前提是当前路径下没有一个叫test2的目录或者文件.

## 删除

在linux下最出名的删除命令就是rm.

```shell
rm test
```

这条命令表示删除当前路径下名为test的文件.

但是rm并不能直接删除非空的目录.如果要删除非空目录,有一个臭名昭著的命令:

```shell
rm -rf test
```

这里的'-rf'是一个命令参数.它表示rm命令将会强制递归执行.这样即使test是一个非空目录也能删除掉.

rm命令最大的缺点就是删除的文件基本没办法找回.一旦误操作,就会造成不能挽回的损失.

所以我建议在日常使用中使用可以恢复的trash命令来替代rm.关于trash命令的介绍请参照我的另一个专栏系列<<太玄的工具库 0X11 trash-cli>>.

## 查找

想要在文件系统中寻找一个忘记放哪里的文件简直就是大海捞针。你可以使用GNU findutils这个工具集中的命令查找文件。一个比较常用的命令就是find命令。例如用find命令查找/bin路径下所有以“n”开头的文件：

```shell
find /bin -name "n*"
```

详细的使用方法参见它的手册。

## 正则表达式

rm之所以臭名远扬,和这条命令有很大关系:

```shell
rm -rf /*
```

这条命令会强制删除所有根目录下的文件.而我们知道,Linux系统中所有文件都在根目录之下.这就等于删除了系统中的所有文件.

这条命令中的'/*'就是指根目录下的全体文件.这是一个正则表达式的写法.星号表示匹配任意名称的文件.

关于bash的正则表达式的用法将在后边进行详细介绍.个人认为正则表达式是一个非常实用的bash功能.它能极大得提高工作效率.不过使用时也要小心,以防出现删除整个系统这种问题.

## 文件链接

Linux中有两种文件链接.一种是软连接,一种是硬链接.

软链接,又称符号链接,类似于Windows中的快捷方式.一个软连接本身是一个小文件,记录了另一个文件的路径等信息.当我们执行或者编辑这个文件的时候会自动跳转到它所记录的另一个文件上.例如(假设test是一个文件夹):

```shell
ln -s test testsoft
```

这里的'ln -s'用于创建软链接.'test'是被链接的文件,'testsoft'所创建的软连接名称.之后我们执行:

```shell
cd testsoft
```

其实是跳转到了test文件夹下(但是路径会显示我们在testsoft目录下,这是为了cd等命令的逻辑不混乱.应该明白testsoft本身不是一个目录).

如果使用rm等命令删除软连接,会删除软连接文件本身,而不会删除它所链接的文件.

使用readlink命令查看软链接所指向的文件.

```shell
readlink testsoft
```

硬链接使用起来有点类似软连接.以下命令给afile创建了一个硬链接:

```shell
ln afile afilehard
```

硬链接和软连接有两点主要区别.

第一,硬链接只能链接文件,而不能链接目录或者本地文件系统以外的文件.

第二,如果删除原文件,剩下的软连接就会失效(虽然软链接文件还存在).如果删除原文件,但是有硬链接到这个文件,那么还是可以通过硬链接来访问这个文件.只有所有硬链接都删除,才算把这个文件删掉.

这些特性和硬链接的实现原理有关.其实原文件也是文件的一个硬链接,新建一个硬链接之后相当于一个文件有两个硬链接(类似于编程中同一个引用类型值被赋予了两个变量,只有当这两个变量都被删除,值所占用的空间才能释放).这里不详细展开,有兴趣可以搜索一下.

此外,Coreutils还提供了一个和链接有关的link,unlink等命令.

最后特别提醒,硬链接不等于复制.如果通过一个硬链接修改了文件,会影响所有这个文件的硬链接.

## 其他文件操作命令

GNU Coreutils还提供了一些其他的文件复制或者删除命令.他们在功能上有不同的侧重,例如dd,shred,rmdir,install等.在这里不一一介绍.详情可以参考手册或者文档.

还有一些命令其实带有一定的编辑功能,例如用于分割文本文件的split和csplit等,同样不详细介绍.

## 文件摘要

所谓的"文件摘要"是指利用摘要算法根据一个文件计算出来的一个数或者一个字符串.生成的摘要的特点是,虽然文件摘要远远小于文件本身的大小,但是文件只要有一丁点的修改,其摘要就会对应地有巨大变化.

虽然说肯定存在两个不同文件的文件摘要相同的情况.但是在一般使用中,出现这种情况的可能性非常低.如果由于数据量增大,导致文件摘要重复的可能性不能忽视,我们只要换用更长位数的文件摘要就可以了.另外,由于文件摘要的信息量要小于文件本身.所以要从文件摘要逆向准确推算出文件本身基本是不可能的.除非生成所有肯能的文件,然后把这些文件分别求摘要,然后和已知的摘要进行比较.

由于文件摘要的这些特点,它经常被用于快速确定文件有没有被修改,或者校验文件完整性.

Coreutils中提供了b2sum, md5sum, sha1sum等命令用于计算文件摘要.

此外还有wc等简单的文件统计工具(统计行数,词数等).
