# 0X08 进程管理

## 进程

进程的准确定义其实现在还有争议.简单点说,一个程序执行一次就是一个进程(或者说电脑在做的一件事).

为了后续叙述方便我就说一下我自己对进程的理解(不一定对):

我们都知道计算机要执行一个任务,需要硬件与软件,算法和资源的配合.但是在硬件资源中,CPU和内存又占有特殊地位.一个程序运行的时候可以不需要打印机,不需要键盘输入,不需要显示器,但是不能没有CPU和内存.

为了合理规划任务执行,提高硬件利用率.就需要对CPU和内存的使用进行管理.这就引申出了操作系统的基本任务中的两个--内存管理和CPU管理.

进程就是在CPU管理和内存管理中提出的一个概念.一般来说,一个进程对应一个任务.把CPU工作时间,内存空间,其他硬件设备使用权等资源提供给它,它就能运作并完成我们的任务(如果进程中运行的程序代码没有问题的话).

但是,认为一个进程对应一个程序也是不妥的.因为我们所说的"任务"其实是一个模糊的概念.你可以把写完今天的英语作业看作一个任务.也可以把写完今天的数学作业看作一个任务.也可以把写完今天的所有作业看作一个任务.同样,一个进程中可以包含一个程序,也可以包含多个相关的程序.甚至可能是一个程序多次启动,产生多个进程--例如之前遇到过的在一个bash中启动另一个bash.

具体是那种情况,就看启动进程的代码怎么写了.实现具体程序的时候,选择单进程还是多进程,选择几个进程,这些问题一言难尽,不在这里做讨论.感兴趣可以去自行搜索一下相关内容.

## 进程树

就像我们做事一样,一个大任务看起来很困难.那就可以把大任务先分割成若干小任务去做.小任务如果还复杂,就分割成更小的任务.很多情况下为了及时性或者提高系统资源利用率等原因,把所有任务排个队,挨个完成的单进程模式并不是最好的选择.

当一个进程认为有必要把一部分任务分配给另一个进程的时候,就可以调用系统中特定的系统接口,会创建一个新的进程.被创建的那个新进程相对于原来的进程,叫做子进程.而创建新进程的进程叫做父进程.父子关系是相对的,很多进程一方面是一个进程的子进程,另一方面又是很多别的进程的父进程.

在进程管理的时候.如果一个进程没有子进程,那么它本身运行完就算完成了.但是如果一个进程有子进程没有运行完,我们就认为它本身没有运行完(因为子进程其实是分担了父进程的部分任务).因而,正常情况下,有子进程尚未终止的进程是不允许终止的.如果一定要终止,需要先对其子进程做处理(比如把要终止进程的子进程交给要终止的进程的父进程作为要终止的进程的父进程的子进程).

一般来说,能创建进程的只有另一个进程,除了一开机启动的那个初始进程.如果不考虑游离的进程的话,一个系统中所有的进程按照父子关系联结起来就构成一个树的形状.称为进程树.之后介绍的一些工具可以形象地展示出进程树.

## 实验准备

如果没有多个同时存在的进程,讨论进程管理就是没有意义的.但是到现在为止我们所介绍的大部分命令只需要很短的时间就能运行完.因此我们需要自己用脚本写一个不会自动终止的程序用于演示进程.下边是我用Lua写的一个死循环的程序.文件名为`loop.lua`.

```lua
while true do
end
```

## 后台运行

很多从bash启动的程序都是默认前台运行的.所谓前台运行就是说会占用终端.如果我们直接执行`loop.lua`,那么终端就会被它阻塞,无法输入别的命令.所以需要让它后台运行(仍然执行脚本中的命令,但是不占用键盘和显示器).

在输入命令时如果后接`&`则会后台运行.例如:

```shell
lua loop.lua &
```

## jobs和kill

使用bash内置命令jobs可以查看当前bash下运行的工作.后加参数`-l`显示详细信息

如果执行jobs前已经后台启动了`loop.lua`,那么就能看到这个进程.例如我这里显示:

>[1]+  1117 Running                 lua loop.lua &

其中方括号内的1是工作号(job number),1117是进程号(process ID).Running是执行状况.`lua loop.lua`是进程名.&符表示程序后台运行.(进程在操作系统中由PID(Process ID)标识.在使用bash的进程管理时，还会给每个可以管理的进程分配一个工作号(job number).)

想要终止这个后台进程,使用这个命令杀死进程:

```shell
kill -9 %1
```

在百分号后写的是工作序号,也就是用jobs查看工作的时候,`loop.lua`这一项的序号.

## 更多查看进程的方法

`ps`命令会给当前的进程状态做一个快照,然后输出.但是它不显示进程的工作号.仅仅显示进程的进程号.

```shell
ps -A
```

后加参数`-A`会显示所有进程.

`pstree`命令则会把进程按照进程树的树形结构排布输出.

`ps`, `pstree`, `jobs`所查看的都是一瞬间的静态信息.`top`命令显示的信息则是不断刷新的.要退出top程序,按键q.

## 关于kill

进程之间,为了协调合作或者相互控制需要进行通信.kill命令其实是bash用于向其他进程发送信号的命令.但是日常最常用的用途就是用它来发送强制终止进程的信号.

要想从命令行终止进程则使用kill命令加要终止的进程的PID。（前提是你拥有终止该进程的权限。）例如：

```shell
kill 1810
```

这时kill默认发送普通的结束请求(SIGTERM,对应数字为18),这个信号不会强制其他进程终止.但是有的程序有时会忽视这个请求。所以还需要加额外参数指定强制终止信号：

```shell
kill -s KILL 1810
```

其中参数`-s`表示要向进程发送信息,`KILL`是要发送的信息,意在让进程立即终止.

更简单的写法是:

```shell
kill -9 1810
```

指定进程也有多种方法.之前例子中，kill后的1810是程序PID.也可以用工作号指定.但是工作号之前需要加百分号%.

`%+`和`%-`可以用于最近后台启动或暂停过的进程.具体指那个进程，可以通过jobs列表中工作号后的加减号辨别.带加号的被称为默认作业.带减号的是下一个默认作业.默认作业完成后下一个默认作业成为默认作业.`%`后接进程名的部分拼写也可以指进程.这其中还可以用一些正则表达式规则.

为了进一步说明kill命令先介绍一个suspend命令(这是bash的内置命令).如果执行这个命令的shell不是一开登录打开的shell,那么就会暂停当前shell.只有接收到SIGCONT信号时才会继续运行.

就如刚才所说,kill命令不仅仅用于终止进程.它的完整功能是给指定进程传送信号.kill所支持的信号可以通过`kill -l`查看.

可以做一个实验,打开两个虚拟终端,假设其中一个的bash的PID是2619(可以用ps、htop等工具查看).在2619上运行suspend命令暂停bash.然后在另一个终端执行`kill -18 2619`就可以继续被暂停的bash
(SIGCONT对应数字18).

个人认为有一个更好用的命令`killall`.它是按名称搜索的.

## 进程状态

进程有三种基本状态：就绪，执行，阻塞。外加创造进程时的开始和完成进程后的结束，一共五种状态。而进程管理就是根据各个进程的执行状况和现在的资源情况让进程们在这几种状态之间来回切换。为了调度方便，一般还增加一种挂起状态（其实是两种状态——静止阻塞，静止就绪）。

在进行调度的时候,其实只用操心进程是不是在'跑'(run).如果进程正常推进,则一切ok.对于正在运行的进程,我们可以通过命令让它暂停推进.如果进程暂停.我们又可以用命令让进程继续运行.

此外我们还能用命令让进程停止运行(SIGTERM).如果进程无法停止,则可以强制停止(KILL).












## 守护进程

守护进程的作用.systemd的命令

toollib介绍systemd

toollib介绍systemd

## 内存查看

## 快捷键和其他

## 视频演示

介绍less

一个进程中包含所要执行的任务代码,以及执行任务所需要的资源(内存空间等).

1. 内存状态查看

    没有直接的命令查看当前内存情况。Linux提供了一个文件用以映射当前内存实况。访问这个文件就能获得当前的内存信息。因此使用以下命令就能查看内存状态。

    >more /proc/meminfo

    这里用cat查看

2. 目前的操作系统绝大多数都提供了并发性。要想查看当前Linux系统正在运行的进程信息，可以使用ps命令。其中的PID是系统内部用于识别不同进程的编号。

3. Linux中可以使用Ctrl+S挂起程序，用Ctrl+Q解除挂起。

4. 要想让当前在前台执行的程序暂停，返回命令行。则使用Ctrl+Z快捷键。如果要从命令行返回执行则使用fg命令。


6. 进程之间的通信是可以通过一种名为“管道”的方式。

    在shell中使用管道符`|`来表示管道。简单来说在这个符号后边的程序以前边程序的输出为输入。例如用less查看ls命令的输出：

    >ls | less

7.  重定性操作符可以完成和管道类似的功能。重定向操作符有`>`,`<`等。

    >ls > lsout.txt

    表示新建一个文件`lsout.txt`,并把ls命令执行结果保存进去。

    >cat < lsout.txt

    表示将`lsout.txt`作为cat命令的输入（cat命令本来是从标准输入读入一行然后在显示器上显示一行）。

## 进程控制快捷键
1. 直观地理解，一个程序在前台运行就会用它的界面覆盖bash的命令行界面（例如正常启动的vim）。而后台运行的程序不会这样。但是注意后台运行的程序其实也可以通过调用输入输出流把文字输出到终端（例如后台运行的yes）。
2. 进程控制快捷键可以在无法向bash输入命令时控制进程。但是只对前台进程有效。另外这组快捷键并非由bash定义，而是由终端驱动解析，可以通过stty命令查看或修改（`stty -a`查看所有快捷键）。
    * C-z 暂停当前进程，并把控制权交还bash。
    * C-y 延迟暂停进程，当进程试图读取输入流时暂停进程并把控制权交还bash。
    * C-s 暂停当前进程，但不交还控制权给bash。
    * C-q 使用C-s暂停进程后使用C-q继续进程。
    * C-c 终止当前进程，返回bash。
3. 这些快捷键的本质是向当前前台进程发送信号。例如C-c发送SIGINT信号，C-z发送SIGTSTP信号。

## 其他进程调度操作
2. fg后接进程，将指定进程调至前台运行。
3. bg后接进程，将指定进程调指后台运行。
4. wait后接子进程。执行wait命令时bash将等待，当指定子进程结束后返回bash。
5. disown后接子进程。当bash退出时不会连带用disown指定的子进程一起退出。由于原有父进程终止，这个子进程将被挂到bash的父进程上。
6. 为以后介绍nohup做个铺垫。disown虽然和nohup看起来效果类似，但是对输入输出流的处理不一样。disown的进程默认情况下输出流仍然和Shell一致。而nohup一般会关闭进程输入流，并且把输出流定向到它指定的文件。