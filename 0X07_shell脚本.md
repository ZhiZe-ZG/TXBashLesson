# 0X07 shell脚本

## 脚本基础

在使用bash的时候，经常有大段重复性或相似性的命令输入。为了减轻使用者负担，可以将这些命令段落用文本记录下来，然后让bash读取文本中的命令逐条执行。这个记录命令序列的文本就叫做脚本。脚本本是剧本的意思。bash编程工作就像是给bash写剧本让它按着去演，所以这里用了脚本一词。

编写脚本十分简单，就是把命令按顺序写在文本中。一行一条命令。如果希望把多条命令写在同一行。各条命令之间用分号隔开。

## 编写脚本

编写shell脚本和lua脚本类似.直接用文本编辑器编写.例如我写了一个脚本,名为'my.sh'.其内容为:

```shell
echo 'hello world'
ls
echo 'bye'
```

要执行的时候也和lua脚本类似,解释器(bash,zsh,sh或者别的什么shell)后加文件名作为参数.例如:

```shell
bash my.sh
```

另外,shell脚本有一个特权,就是可以像二进制可执行文件一样,直接输入文件路径就执行.

不过对于这个我们刚刚编写好的脚本,还要修改其文件权限,使得可以执行(后边会详细讨论文件权限的问题).

```shell
chmod 755 my.sh
```

然后执行:

```shell
./my.sh
```

如果这个文件所在目录刚好在环境变量PATH中.那么直接输入文件名就能执行(要写全后缀名).

## 注释和约定

脚本中如果一行以`#`开头,则这行是注释.

有时候脚本文件最开头会看见这样的注释:

```shell
#!/bin/sh
```

```shell
#!/bin/bash
```

```shell
#!/bin/zsh
```

这是一些约定俗成的写法,用于说明这个脚本需要用哪个shell来解析.

## 启动文件

shell在启动的时候会自动执行一些脚本，初始化环境变量和一些shell脚本函数。这些脚本称为启动文件。

启动文件主要有对所有用户都起效的/etc/profile(以及/etc/profile.d中的脚本文件)和用户定制的启动文件两类。

shell有三种启动模式，根据启动模式不同，会使用不同的启动文件。这三类启动模式是：

* 用户登录后启动的shell。
* 非登录启动的交互式shell。例如在其他shell进程中用命令bash启动的bash shell。
* 用于执行脚本的非交互式shell。每当运行一个脚本，就会自动启动一个bash执行它。由于我们不能通过键盘给这个进程输入命令，所以称为非交互式。

登录启动的shell首先会执行/etc/profile。如果需要初始化的东西很多还会有一个/etc/profile.d文件夹。profile会调用这个文件夹中的脚本。其他两种shell启动方式不执行/etc/profile。但是由于它们是登录shell的子进程，会继承登录shell的一些变量。

登录启动的shell执行完/etc/profile后会执行$HOME下用户专属的启动文件。按执行顺序有以下几个：

* $HOME/.bash_profile
* $HOME/.bash_login
* $HOME/.profile

还要注意以下几点

* 另有一个$HOME/.bashrc被其他脚本调用而执行。
* 这些文件不一定都要有。一般只会用到一两个。
* 交互式shell在启动时还会执行一次`$HOME/.bashrc`。
* 非交互shell在启动时默认不执行启动文件。如果需要启动文件，可以在环境变量BASH_ENV中指定。

顺便说一句，Linux系统中的很多设置（不管是系统本身还是别的软件）都是通过修改`.bashrc`这种配置文件来实现的。

## 修改持久化

shell中定义的命令别名或者对变量做的修改都是临时性的.一旦shell重启就会消失.

如果你希望保存对环境变量的修改，或者希望在启动shell后自动执行一些命令。就可以修改shell的启动文件。是一般不把大量的修改直接放到系统默认的启动文件中。而是先写一个自己的启动脚本，然后在标准的启动文件中调用自己的脚本。另外，尽量不扩大修改的影响范围。如果不是必须让所有用户都用的修改，就尽量不修改在/etc/profile中。

尽量把自定义局限在用户内，而不扩散到全局。这样即使出现问题，也不会影响其他用户账号。

如果一定要修改profile,建议把修改内容写成/etc/profile.d中的一个后缀为'.sh'的文件.否则,请尽量把自己的命令别名,启动脚本写到'.bashrc'中.(如果使用zsh,就是'.zshrc')

## export

如果你希望一个变量,被当前shell的子进程shell所继承.则对这个变量使用export命令.例如:

```shell
myV=12345
echo $myV
bash
echo $myV
exit
export myV
bash
echo $myV
```

## 退出状态

在shell脚本中使用exit命令就会退出脚本的执行.exit后如果有参数,就会把参数作为退出状态值(相当于函数值)返回.

例如我有一个脚本名为`my.sh`,内容为:

```shell
echo hello
exit 134
```

执行脚本后,特殊变量`?`中保存了上一条命令的退出状态.查看这个变量就是查看上一条命令的退出状态.

```shell
./my.sh
echo $?
```

其实所有命令都有退出状态.如果退出状态为0(exit不带参数时也默认返回0),表示程序正常结束.否则程序意外终止.一般来说不为0的退出状态表示程序所遇到的异常号.

顺便说一句,冒号`:`也是一个bash内建命令.它也可以接收参数,但是什么都不做.而且退出状态总是0.

注意退出状态和命令执行时的输出内容不是一回事:

```shell
tempV=$(./my.sh)
echo $tempV
./my.sh
echo $?
```

## 更多执行脚本的方式

执行脚本除了以上介绍的两种方式:

```shell
bash my.sh
./my.sh
```

还可以用句点`.`,这也是一个bash内置命令.它的作用是逐句读出脚本中的命令然后执行(source命令与之有同样的效果).

```shell
. my.sh
```

一般我们执行脚本的时候其实是启动了一个当前shell的子进程shell脚本.但是使用句点命令后,就在当前shell中执行脚本.一个明显的例子就是,如果`my.sh`中有`exit`命令.那么:

```shell
bash my.sh
```

不会退出当前bash.而:

```shell
. my.sh
```

退出当前bash.
